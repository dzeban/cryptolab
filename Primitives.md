## Примитивы ##

В общем, здесь надо определить список того, что нам нужно будет сделать самим, а что есть в GMP.


| **Примитив** | **Реализован в GMP** | **Комментарий** |
|:---------------------|:--------------------------------|:---------------------------|
|Простые арифметические операции| void   mpz\_add     (mpz\_t rop, mpz\_t op1, mpz\_t op2) <br> void   mpz_add_ui      (mpz_t rop, mpz_t op1, unsigned long int op2) - записывает в переменную rop сумму op1 и op2 <br><br> void   mpz_sub     (mpz_t rop, mpz_t op1, mpz_t op2) <br> void   mpz_sub_ui      (mpz_t rop, mpz_t op1, unsigned long int op2) <br> void   mpz_ui_sub      (mpz_t rop, unsigned long int op1, mpz_t op2)  - записывает в переменную rop разность op1 и op2 <br><br> void   mpz_mul     (mpz_t rop, mpz_t op1, mpz_t op2) <br> void   mpz_mul_si      (mpz_t rop, mpz_t op1, long int op2) <br> void   mpz_mul_ui      (mpz_t rop, mpz_t op1, unsigned long int op2) - записывает в переменную rop произведение op1 и op2 <br><br> void   mpz_addmul (mpz_t rop, mpz_t op1, mpz  t op2) <br> void   mpz_addmul_ui (mpz_t rop, mpz_t op1, unsigned long int op2) - записывает в переменную rop значение rop+op1*op2 <br><br> void mpz_submul (mpz_t rop, mpz_t op1, mpz_t op2) <br> void   mpz_submul_ui (mpz_t rop, mpz_t op1, unsigned long int op2) - записывает в переменную rop значение rop-op1*op2 <br> <br> void   mpz_neg     (mpz_t rop, mpz_t op) - записывает в rop значение -op <br><br> void   mpz_abs     (mpz_t rop, mpz_t op) - записывает в переменную rop абсолютное значение op <br><br> void    mpz_tdiv_qr       (mpz_t q, mpz_t r, mpz_t n, mpz_t d) <br> unsigned long   int    mpz_tdiv_qr_ui    (mpz_t q, mpz_t r, mpz_t n , unsigned long int d)  - делит n на d и записывает в q частное, а в r остаток <br><br>  void    mpz_mod     (mpz_t r, mpz_t n, mpz_t d) <br> unsigned      long    int   mpz_mod_ui       (mpz_t r, mpz_t n, unsigned long int d) - записывает в r остаток от деления n на d <br><br> void mpz_pow_ui (mpz_t rop, mpz_t base, unsigned long int exp) <br> void    mpz_ui_pow_ui        (mpz_t rop, unsigned long int base, unsigned long int exp) - записывает в rop значение base<sup>exp</sup>;0<sup>0</sup>=1<table><thead><th>+,-,<code>*</code>,/,^,%</th></thead><tbody>
<tr><td>Модульная арифметика</td><td> void    mpz_powm (mpz_t rop, mpz_t base, mpz_t exp, mpz_t mod1 ) <br> void    mpz_powm_ui       (mpz_t rop, mpz_t base, unsigned long int exp, mpz_t  mod1 ) - записывает в rop значение base<sup>exp</sup>mod(mod1)</td><td>+(mod), -(mod), <code>*</code>(mod), /(mod), ^(mod)</td></tr>
<tr><td>Сравнения</td><td> int   mpz_cmp  (mpz_t op1, mpz_t op2) <br> int mpz_cmp_d  (mpz_t op1, double op2)  <br> int   mpz_cmp_si  (mpz_t op1, signed long int op2) <br> int   mpz_cmp_ui  (mpz_t op1, unsigned long int op2) - возвращает 1, если op1>op2, 0 если op1=op2, -1 если op2>op1 <br><br> int   mpz_cmpabs  (mpz_t op1, mpz_t op2) <br> int   mpz_cmpabs_d  (mpz_t op1, double op2) <br> int   mpz_cmpabs_ui  (mpz_t op1, unsigned long int op2) - сравнивает абсолютные значения <br><br> int   mpz_sgn  (mpz_t op) - возвращает 1, если op>0, 0 если op=0, -1 если op<0</td><td><,>,<=,>=, !=, ==</td></tr>
<tr><td>НОД</td><td> void    mpz_gcd     (mpz_t rop, mpz_t op1, mpz_t op2) - записывает в rop значение НОД(op1, op2) <br><br> void    mpz_gcdext       (mpz_t g, mpz_t s, mpz_t t, mpz_t a, mpz_t b) - записывает в g НОД(a, b), а в s и t значения, удовлетворяющие равенству as+bt=g. При этом g всегда положительное вне зависимости от знаков a и b.</td></tr>
<tr><td>НОК</td><td> void    mpz_lcm     (mpz_t rop, mpz_t op1, mpz_t op2) <br> void    mpz_lcm_ui       (mpz_t rop, mpz_t op1, unsigned long op2) - записывает в rop значение НОК(op1, op2) </td></tr>
<tr><td>Мультипликативно обратное</td><td> int   mpz_invert  (mpz_t rop, mpz_t op1, mpz_t op2) - записывает в rop  мультипликативно обратное op1(mod op2)</td></tr>
<tr><td>Функция Эйлера</td><td> - </td></tr>
<tr><td>Символ Якоби</td><td> int   mpz_jacobi  (mpz_t a, mpz_t b)  </td></tr>
<tr><td>Символ Лежандра</td><td>int   mpz_legendre  (mpz_t a, mpz_t p )</td></tr>
<tr><td>Разложение на множители</td><td> - </td></tr>
<tr><td>Поиск простых чисел</td><td> void mpz_nextprime (mpz_t rop, mpz_t op) - записывает в rop следующее простое число  после op</td></tr>
<tr><td>Проверка на простоту</td><td> int   mpz_probab_prime_p  (mpz_t n, int reps ) - проверяет на простоту число n. Возвращает 2 в случае, если n точно простое, 1, если возможно простое и 0, если составное.<br> В данной функции реализован тест Миллера-Рабина. Переменная reps задает количество тестов.</td></tr>
<tr><td>Генерация случайных чисел</td><td> void    mpz_urandomb       (mpz_t rop, gmp_randstate_t state, mp_bitcnt_t n ) - генерирует равномерно распределенную случайную величину в диапазоне от 0 до 2<sup>n</sup>-1 включительно <br><br> void    mpz_urandomm       (mpz_t rop, gmp_randstate_t state, mpz_t n ) - генерирует равномерно распределенную случайную величину в диапазоне от 0 до n-1 включительно  </td></tr>
<tr><td>Целочисленный корень</td><td> int   mpz_root  (mpz_t rop, mpz_t op, unsigned long int n ) записывает в rop целочисленное значение n-го корня из op <br><br> void    mpz_rootrem       (mpz_t root, mpz_t rem, mpz_t u, unsigned long int n ) - записывает в root целочисленное значение n-го корня из u, а в rem значение остатка: u-root<sup>n</sup> <br><br> void    mpz_sqrt     (mpz_t rop, mpz_t op) - записывает в rop целочисленное значение квадратного корня из op <br><br> void mpz_sqrtrem (mpz_t rop1, mpz_t rop2, mpz_t op) - записывает в rop1 целочисленное значение квадратного корня из op, а в rop2 значение остатка: op-rop1<sup>2</sup> <br><br> int   mpz_perfect_power_p  (mpz_t op) - возвращает неотрицательное значение, если существует такое a и b>1, что op=a<sup>b</sup> <br><br> int   mpz_perfect_square_p  (mpz_t op) - возвращает неотрицательное значение, если op является квадратом какого либо целого числа </td></tr>