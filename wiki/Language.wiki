#summary Данная страница содержит описание языка, на котором будут писаться приложения в IDE
#labels Phase-Design

= Введение =
Итак, друзья. Наиболее важная часть нашего замечательного проекта - это язык, на котором будут писаться криптоштуки. Поэтому сюда мы выливаем все мысли относительно того, как он должен выглядеть.


= Описание языка =
Для нашего языка программирования главное, чтобы он был прост, интуитивно понятен для криптографа-теоретика, выразителен и конечно удобен.

== Арифметика ==
С чего начать? Начнем с арифметики. Дельше будет две колонки: операции и их представления в нашем языке соответственно.


|| *Операция* || *Представление* || *Комменты* ||
||Простые арифметические операции||+,-,`*`,/,^,%||Здесь все как обычно||
||Клевые арифметические операции||++,--,+=,-=,`*`=||Я считаю, без них никак||
||Модульные опреации||+(mod), -(mod), `*`(mod), /(mod), ^(mod)||Пример: (x+67-3`*`34)(mod y) - думаю так||
||Сравнения||<,>,<=,>=, !=, ==||Помоему еще нужны операции сравнения по модулю||

Ну вот наверное и все с арифмитическими операциями.

== Множества, переменные и элементы ==
Здесь необходимо определить место для понятий "Множества, переменные, объекты" в нашем языке, ибо это пипец, какие важные понятия.
Итак, у нас есть множества и элементы этих множеств. Так вот, условимся, что операция взятия элемента из множества выглядит так: "<-" (пример: e<-Z). А операция присвоения как всегда "=" (пример: e=phi(p,q)).

Чтобы создать какой-то криптоалгоритм, надо определить с чем мы имеем дело: с полем целых чисел, циклической группой, группой перестановок или полиномами, а потом уже начинать творить чудеса. Для этих целей в нашем языке будет класс идентификаторов, предназначенных для объявления множеств: Field, Group, Ring, и т.д.

Чтобы задать группу надо сказать: Group G{type:cycklic(2)}.
А чтобы взять элемент из группы, надо сделать g<-G{len>1000b}, чтобы присвоить элемент g элементу r получаем r=g.

Оператор <- также предназначен для взятия значения из промежутка, например: g<-`[`0,1000`]`.


Таким образом:
 * { } - для задания опций различных операций
 * `[` `]` - для указания промежутков и конечно индексации массивов
 * ( ) - для указания интервалов, аргументов функций и арифметических операций.


== Си-подобные ==
Здесь у нас будет таблица с минимальным набором функций, которые к тому же никак не напишешь кроме как в Си-подобном виде.
|| *Функция* || *Представление* ||
||НОД||gcd()||
||НОК||lcm()||
||Мультипликативно обратное||mul_inv()||
||Функция Эйлера||phi()||
||Символ Якоби||jacoby()||
||Символ Лежандра||leg()||
||Целочисленный корень||sqpt()||
Эту таблицу надо дополнять.

== Примеры ==
=== RSA ===
{{{
/*Реализация криптосистемы RSA на одной вычислителной машине*/

Field F{int}; \\Создаем поле F
p<-F{len > 1000b}; \\Берем случайный элемент p из поля F длиной больше 1000 бит
q<-F{len > 2000b};
n = p*q; \\n = произведение p на q
fi = phi(p,q); \\fi = функция эйлера от аргументов p и q
e<-[1,fi-1]; \\Берем случайное e из промежутка от 1 до fi-1
d = mul_inv(e,fi); \\d = мультипликативно обратное от e по модулю fi
echo "Please type number to encrypt:"; \\просим пользователя ввести сообщение
m = scan(stdin); \\считываем с клавиатуры
c = m^e(mod n); \\шифруем: с = m в степени e по модулю n
mm = c^d(mod n); \\расшифровываем
if(mm == m) echo "All done";
else echo "Error"; 
}}}
=== DH ===
{{{
Field F{int};
a<-F{len > 10b};
Group G{int,gen(a)};
x<-[1,a];
ax = a^x;
y<-[1,a];
ay = a^y;
k = a^(x*y)

y = receive(B);
key = ax^y;
}}}