#summary Данная страница содержит описание языка, на котором будут писаться приложения в IDE

= Введение =
Итак, друзья. Наиболее важная часть нашего замечательного проекта - это язык, на котором будут писаться криптоштуки. Поэтому сюда мы выливаем все мысли относительно того, как он должен выглядеть.


= Описание языка =
Для нашего языка программирования главное, чтобы он был прост, интуитивно понятен для криптографа-теоретика, выразителен и конечно удобен.

== Арифметика ==
С чего начать? Начнем с арифметики. Дельше будет две колонки: операции и их представления в нашем языке соответственно.


|| *Операция* || *Представление* || *Комменты* ||
||Простые арифметические операции||+,-,`*`,/,^,%||Здесь все как обычно||
||Клевые арифметические операции||++,--,+=,-=,`*`=||Я считаю, без них никак||
||Модульные опреации||+(mod), -(mod), `*`(mod), /(mod), ^(mod)||Пример: (x+67-3`*`34)(mod y) - думаю так||
||Сравнения||<,>,<=,>=, !=, ==||Помоему еще нужны операции сравнения по модулю||

Ну вот наверное и все с арифмитическими операциями.

== Множества, переменные и элементы ==
Здесь необходимо определить место для понятий "Множества, переменные, объекты" в нашем языке, ибо это пипец, какие важные понятия.
Итак, у нас есть множества и элементы этих множеств. Так вот, условимся, что операция взятия элемента из множества выглядит так: "<-" (пример: e<-Z). А операция присвоения как всегда "=" (пример: e=phi(p,q)).

Чтобы создать какой-то криптоалгоритм, надо определить с чем мы имеем дело: с полем целых чисел, циклической группой, группой перестановок или полиномами, а потом уже начинать творить чудеса. Для этих целей в нашем языке будет класс идентификаторов, предназначенных для объявления множеств: Field, Group, Ring, и т.д.

Чтобы задать группу надо сказать: Group G{type:cycklic(2)}.
А чтобы взять элемент из группы, надо сделать g<-G{len>1000b}, чтобы присвоить элемент g элементу r получаем r=g.

Оператор <- также предназначен для взятия значения из промежутка, например: g<-`[`0,1000`]`.


Таким образом:
 * { } - для задания опций различных операций
 * `[` `]` - для указания промежутков и конечно индексации массивов
 * ( ) - для указания интервалов, аргументов функций и арифметических операций.


== Си-подобные ==
Здесь у нас будет таблица с минимальным набором функций, которые к тому же никак не напишешь кроме как в Си-подобном виде.
|| *Функция* || *Представление* ||
||НОД||gcd()||
||НОК||lcm()||
||Мультипликативно обратное||mul_inv()||
||Функция Эйлера||phi()||
||Символ Якоби||jacoby()||
||Символ Лежандра||leg()||
||Целочисленный корень||sqpt()||
Эту таблицу надо дополнять.

== Примеры ==
=== RSA ===
{{{
/*Реализация криптосистемы RSA на одной вычислителной машине*/

Field F{int};					\\Создаем поле F
p<-F{len > 1000b};				\\Берем случайный элемент p из поля F длиной больше 1000 бит
q<-F{len > 2000b};
n = p*q;					\\n = произведение p на q
fi = phi(p,q);					\\fi = функция эйлера от аргументов p и q
e<-[1,fi-1];					\\Берем случайное e из промежутка от 1 до fi-1
d = mul_inv(e,fi);				\\d = мультипликативно обратное от e по модулю fi
echo "Please type number to encrypt:";	        \\просим пользователя ввести сообщение
m = scan(stdin);				\\считываем с клавиатуры
c = m^e(mod n); 				\\шифруем: с = m в степени e по модулю n
mm = c^d(mod n);				\\расшифровываем
if(mm == m) echo "All done";			\\сравниваем сообщения
	else echo "Error";
}}}
=== DH(САНЯ, ПРОВЕРЬ ПРАВИЛЬНОСТЬ АЛГОРИТМА)===
{{{
/*Реализация протокола установления ключа Диффи-Хеллмана*/

Field F{int};					\\Создаем поле F
a<-F{len > 10B};				\\Берем случайный элемент a из поля F длиной больше 1 байта
Group G{int,gen(a)};				\\Создаем группу G из целых с образующей a (это макрос)
x<-[1,a];					\\Берем случайное x из промежутка от 1 до a
ax = a^x;					\\ax = a в степени x
y<-[1,a];
ay = a^y;
key_a = ax^y;					\\Вычисляем ключи
key_b = ay^x;
if(key_a == key_b) echo "All done";		\\сравниваем полученные ключи
	else echo "Error";
}}}
=== EG ===
{{{
/*Реализация протокола Эль-Гамаля на одной вычислительной машине*/
}}}