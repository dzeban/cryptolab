#summary Список примитивов, которые надо реализовать
#labels Phase-Design

== Примитивы ==

В общем, здесь надо определить список того, что нам нужно будет сделать самим, а что есть в GMP.


|| *Примитив* || *Реализован в GMP* || *Комментарий* ||
||Простые арифметические операции|| void   mpz_add     (mpz_t rop, mpz_t op1, mpz_t op2) <br> void   mpz_add_ui      (mpz_t rop, mpz_t op1, unsigned long int op2) - записывает в переменную rop сумму op1 и op2 <br><br> void   mpz_sub     (mpz_t rop, mpz_t op1, mpz_t op2) <br> void   mpz_sub_ui      (mpz_t rop, mpz_t op1, unsigned long int op2) <br> void   mpz_ui_sub      (mpz_t rop, unsigned long int op1, mpz_t op2)  - записывает в переменную rop разность op1 и op2 <br><br> void   mpz_mul     (mpz_t rop, mpz_t op1, mpz_t op2) <br> void   mpz_mul_si      (mpz_t rop, mpz_t op1, long int op2) <br> void   mpz_mul_ui      (mpz_t rop, mpz_t op1, unsigned long int op2) - записывает в переменную rop произведение op1 и op2 <br><br> void   mpz_addmul (mpz_t rop, mpz_t op1, mpz  t op2) <br> void   mpz_addmul_ui (mpz_t rop, mpz_t op1, unsigned long int op2) - записывает в переменную rop значение rop+op1*op2 <br><br> void mpz_submul (mpz_t rop, mpz_t op1, mpz_t op2) <br> void   mpz_submul_ui (mpz_t rop, mpz_t op1, unsigned long int op2) - записывает в переменную rop значение rop-op1*op2 <br> <br> void   mpz_neg     (mpz_t rop, mpz_t op) - записывает в rop значение -op <br><br> void   mpz_abs     (mpz_t rop, mpz_t op) - записывает в переменную rop абсолютное значение op <br><br> void    mpz_tdiv_qr       (mpz_t q, mpz_t r, mpz_t n, mpz_t d) <br> unsigned long   int    mpz_tdiv_qr_ui    (mpz_t q, mpz_t r, mpz_t n , unsigned long int d)  - делит n на d и записывает в q частное, а в r остаток <br><br>  void    mpz_mod     (mpz_t r, mpz_t n, mpz_t d) <br> unsigned      long    int   mpz_mod_ui       (mpz_t r, mpz_t n, unsigned long int d) - записывает в r остаток от деления n на d <br><br> void mpz_pow_ui (mpz_t rop, mpz_t base, unsigned long int exp) <br> void    mpz_ui_pow_ui        (mpz_t rop, unsigned long int base, unsigned long int exp) - записывает в rop значение base^exp^;0^0^=1||+,-,`*`,/,^,%||
||Модульная арифметика|| void    mpz_powm (mpz_t rop, mpz_t base, mpz_t exp, mpz_t mod1 ) <br> void    mpz_powm_ui       (mpz_t rop, mpz_t base, unsigned long int exp, mpz_t  mod1 ) - записывает в rop значение base^exp^mod(mod1)||+(mod), -(mod), `*`(mod), /(mod), ^(mod)||
||Сравнения|| int   mpz_cmp  (mpz_t op1, mpz_t op2) <br> int mpz_cmp_d  (mpz_t op1, double op2)  <br> int   mpz_cmp_si  (mpz_t op1, signed long int op2) <br> int   mpz_cmp_ui  (mpz_t op1, unsigned long int op2) - возвращает 1, если op1>op2, 0 если op1=op2, -1 если op2>op1 <br><br> int   mpz_cmpabs  (mpz_t op1, mpz_t op2) <br> int   mpz_cmpabs_d  (mpz_t op1, double op2) <br> int   mpz_cmpabs_ui  (mpz_t op1, unsigned long int op2) - сравнивает абсолютные значения <br><br> int   mpz_sgn  (mpz_t op) - возвращает 1, если op>0, 0 если op=0, -1 если op<0||<,>,<=,>=, !=, ==||
||НОД|| void    mpz_gcd     (mpz_t rop, mpz_t op1, mpz_t op2) - записывает в rop значение НОД(op1, op2) <br><br> void    mpz_gcdext       (mpz_t g, mpz_t s, mpz_t t, mpz_t a, mpz_t b) - записывает в g НОД(a, b), а в s и t значения, удовлетворяющие равенству as+bt=g. При этом g всегда положительное вне зависимости от знаков a и b.||
||НОК|| void    mpz_lcm     (mpz_t rop, mpz_t op1, mpz_t op2) <br> void    mpz_lcm_ui       (mpz_t rop, mpz_t op1, unsigned long op2) - записывает в rop значение НОК(op1, op2) ||
||Мультипликативно обратное|| int   mpz_invert  (mpz_t rop, mpz_t op1, mpz_t op2) - записывает в rop  мультипликативно обратное op1(mod op2)||
||Функция Эйлера|| - ||
||Символ Якоби|| int   mpz_jacobi  (mpz_t a, mpz_t b)  ||
||Символ Лежандра||int   mpz_legendre  (mpz_t a, mpz_t p )||
||Разложение на множители|| - ||
||Поиск простых чисел|| void mpz_nextprime (mpz_t rop, mpz_t op) - записывает в rop следующее простое число  после op||
||Проверка на простоту|| int   mpz_probab_prime_p  (mpz_t n, int reps ) - проверяет на простоту число n. Возвращает 2 в случае, если n точно простое, 1, если возможно простое и 0, если составное.<br> В данной функции реализован тест Миллера-Рабина. Переменная reps задает количество тестов.||
||Генерация случайных чисел|| void    mpz_urandomb       (mpz_t rop, gmp_randstate_t state, mp_bitcnt_t n ) - генерирует равномерно распределенную случайную величину в диапазоне от 0 до 2^n^-1 включительно <br><br> void    mpz_urandomm       (mpz_t rop, gmp_randstate_t state, mpz_t n ) - генерирует равномерно распределенную случайную величину в диапазоне от 0 до n-1 включительно  ||
||Целочисленный корень|| int   mpz_root  (mpz_t rop, mpz_t op, unsigned long int n ) записывает в rop целочисленное значение n-го корня из op <br><br> void    mpz_rootrem       (mpz_t root, mpz_t rem, mpz_t u, unsigned long int n ) - записывает в root целочисленное значение n-го корня из u, а в rem значение остатка: u-root^n^ <br><br> void    mpz_sqrt     (mpz_t rop, mpz_t op) - записывает в rop целочисленное значение квадратного корня из op <br><br> void mpz_sqrtrem (mpz_t rop1, mpz_t rop2, mpz_t op) - записывает в rop1 целочисленное значение квадратного корня из op, а в rop2 значение остатка: op-rop1^2^ <br><br> int   mpz_perfect_power_p  (mpz_t op) - возвращает неотрицательное значение, если существует такое a и b>1, что op=a^b^ <br><br> int   mpz_perfect_square_p  (mpz_t op) - возвращает неотрицательное значение, если op является квадратом какого либо целого числа ||